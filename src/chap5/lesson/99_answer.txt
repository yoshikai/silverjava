[lesson5_1:B]
デフォルトコンストラクタは、クラス内に明示的なコンストラクタ定義がない場合のみ、
コンパイルのタイミングでclassファイルに追加されます。
従って選択肢Bが正解

[lesson5_2:C]
finalで宣言された変数aの初期化のタイミングはコンストラクタにて初期化して定数としているため、
2,3行目は問題なし。
4行目で変数aに値を代入しようとしているためここでコンパイルエラーが発生する
従って選択肢Cが正解
※finalが宣言された変数が出てきた場合、初期化のタイミングと変更しようとしていないかしっかり確認

[lesson5_3:A]
クラスの実行順序をmain関数から見ていくと、
1.6～7でローカル変数の初期化(※Mainクラスのメンバー変数xとstatic変数yとは別なので注意)
2.Mainクラスをインスタンス化
  この時内部では、Mainクラスのstaticイニシャライザ(初期化子)によって
  14行目が実施され、Mainクラスのstatic変数yにy+=2で4がセット
  次に、コンストラクタ内のx=x+1が実施され、x=3+1で4がセット
3.9行目のprintItメソッド呼び出し
  ++xでインクリメントされた5を出力
4.10行目のprintItメソッド呼び出し
  メインメソッドから渡された10をインクリメントして11を出力
従って出力は、5 11となり選択肢Aが正解

[lesson5_4:A]
メソッドxの仮引数に30を足してmainメソッド側に戻り値として返していない、
または言い方を変えるとMainクラスのメンバー変数に+30された値を持っていないため
mainメソッド内の変数numは10のまま。
従って正解は選択肢A

[lesson5_5:C]
問題4.の改問題。int[]の変数numはオブジェクト＝参照渡しのため、
mainメソッドで作成されたnum変数の10に対して30が付加され、40が出力される。
従って正解は選択肢C

[lesson5_6:B,D,E]
A. staticメソッド内(ここではmain)でインスタンス変数num1を直接参照できないため
   コンパイルエラーが発生
B. 正しい(※コンパイラから警告が出るが実行は可能)
   インスタンス参照からstatic変数にアクセスしているが、コンパイルエラーにはならない
   が、行儀のよいプログラムではないので実務ではこういう記述はしないように
C. インスタンス変数にMain.num1とスタティック変数としてアクセスしているため
   コンパイルエラーが発生
D. data2に静的アクセスし、インスタンス変数num1はnewe Main().num1と正しくアクセスしている
E. 同一クラス内のデフォルト修飾子のstatic変数のdata2にアクセスし、
   num1も選択肢D同様に正しくアクセスしている
上記のように選択肢B,D,Eが正解

[lesson5_7:A,C,D,F]
メソッドのオーバーロードの問題
A. 戻り値:同じ メソッド名:同じ 引数:異なる →OK
B. 戻り値:異なる メソッド名:同じ 引数:同じ →NG
   ※戻り値が異なりメソッド名＋引数が同じ場合、どうやってそのメソッドを呼び出すのか不明なためNG
C. 戻り値:同じ メソッド名:同じ 引数:異なる →OK
D. 戻り値:同じ メソッド名:異なる 引数:同じ →OK
   オーバーロード以前にメソッド名が異なるためOK
E. 戻り値:同じ メソッド名:同じ 引数:同じ →NG
   アクセス修飾子が異なるだけでも呼び出し側でどちらが呼び出されるか不明なためNG
F. 戻り値:同じ メソッド名:同じ 引数:異なる →OK
G. 戻り値:同じ メソッド名:同じ 引数:同じ →NG
   引数の変数名を買えてもメソッドのシグネチャは同じなためNG
※java におけるメソッドのシグネチャとは、メソッド名、引数の型、
引数の数の３つの要素から構成されたもので、メソッドを識別するのに使われます。

[lesson5_8:A,B]
mainメソッドのString[]をそのままfooメソッドに渡しているため、
選択肢BだけがString[]になっているが、可変長配列の選択肢AもString[]とみなせるため
選択肢A,Bが正解
選択肢C,D,EはString[]と互換性がないシグネチャのため間違い

[lesson5_9:C,D,H]
A. OK staticメソッドからstaticメソッドの呼び出しはOK
B. OK クラス名つきstaticメソッドからstaticメソッドの呼び出しもOK
C. NG インスタンスメソッドをstaticメソッド呼び出しを行っているためNG。
   インスタンスメソッドはその名の通りオブジェクトのインスタンスからしか呼び出せない。
D. NG 選択肢Cの説明と同様。
E. OK 同一クラス内からであればクラス名.staticメソッド形式でなくてもメソッド名のみで使用可能
F. OK クラス名.staticメソッド形式の呼び出し方法
G. OK インスタンスメソッドからインスタンスメソッド呼び出しもOK
H. NG　選択肢Cの説明と同様。
従ってコンパイルエラーになるのは選択肢C,D,H

[lesson5_10:A]
Goo型のインスタンス変数gはメッセージを変更されていないため、g.getMsg()では
コンストラクタに渡された文字列"Goo"のため、選択肢B,Dは間違い
Boo型の変数bは23行目でuseGooメソッドを呼び出し、useGooメソッド内で
コンストラクタで渡された"Boo"文字列をsetMsgメソッドにて、"Goo"文字列に更新しています
そのためb.getMsg()メソッドの戻り値は"Goo"になるため
出力はGoo:Gooの選択肢Aが正解

[lesson5_11:C]
オブジェクトの比較の問題。
3行目、4行目は同じオブジェクトのインスタンスを作成しているが、別のオブジェクトになるため
5行目の比較はfalse
6行目のoparateメソッドでobj3の変数を戻り値として帰しているが、中身はojb1のため
同一参照の変数を比較しているため7行目はtrue
従って選択肢Cが正解

[lesson5_12:B,C]
13,14行目でFoo1,Foo2をインスタンス化、
17行目でFoo1のオブジェクトf1に10をセット、
18行目で、Foo2のオブジェクトf2にf1をセットし、
f2にf1の参照をセットしています。
そのためf1の状態(ここではint型変数x)がどう変わろうともf2はf1を参照しているため、
f1に100をセットしている選択肢B,Cが正解となる。
またf2は(Foo1を継承している訳ではないので)setXメソッドがないため、
選択肢A,Dはコンパイルエラーとなる。
選択肢Eのx=100はxが宣言されていないためコンパイルエラーとなる。
従って選択肢B,Cが正解

[lesson5_13:E]
10行目でFoo型オブジェクトf1を500でインスタンス化し、11行目でgetXで500を出力
12行目でMain型オブジェクトobjをインスタンス化し、
toObjメソッドで(※10行目でインスタンス化された)f1のgetXで3:500を出力(18行目)
19行目に17行目でインスタンス化されたf2(100)を返し、
14行目f2.getXメソッドで100を出力
なので出力は
1:500
3:500
2:100
の選択肢Eが正解

[lesson5_14:E]
11行目で出力しているvalは10行目で宣言されたvalのため出力は10
12行目で10を渡しているが、メソッドxでvalに9をセットし、出力
※この時点で出力は10 9となっているため選択肢Eが正解とわかる
また13行目ではvalを出力しているが、valはint型のため参照渡しではなく値渡しのため、
(12行目のメソッドxの影響を受けていない)10の値を持つ、valを出力
※9ではないことに注意
14行目では9行目で8にセットされた値を出力
従って出力された値は10 9 10 8とんるため選択肢Eが正解

[lesson5_15:E]
xがstatic変数、yがインスタンス変数なところを注意
Main型変数obj1、obj2を5,6行目でインスタンス化しているが、
7行目から10行目までで各変数の値を更新しているが、
9行目にx=7にしているので、obj1,obj2ともにxは7で出力される
そのため選択肢はC～Eのいずれかに絞られる。
obj1のインスタンス変数yは8行目で6、
obj2のインスタンス変数yは10行目で8
に更新されているため7678と出力される
正解は選択肢E

[lesson5_16:A]
簡単な問題。
mainメソッドにてval1を参照しているがmainメソッドはstaticであるため、
val1を参照するにはMainクラスのインスタンスから参照するか、staticに変更すれば良いため
正解は選択肢A
選択肢B,C,Dは5行目のコンパイルエラーが解消できないためNG
選択肢Eは、staticイニシャライザを削除し、val1を1で初期化しているが、staticなmainメソッドからは
参照できないためNG

[lesson5_17:D]
1. 5行目で宣言されたString型変数sは6行目で、Mainクラスのインスタンス変数に参照
2. 7行目で変数sに新しいStringのインスタンスが作成されるが、2行目のsが5行目のsをまだ参照している
   ※参照渡し
3. 8行目のfuncXメソッドでnullが渡されたため2行目のsの参照もクリアされ、
   5行目のsがどこからも参照されなくなったためガベージコレクタ対象となる
従って正解は選択肢D

[lesson5_18:C,D]
カプセル化の特徴はアクセス修飾子によるデータの保護と、不変オブジェクトの生成が可能というのが
大きな特徴のため選択肢C,Dが正解
