#模擬試験1の回答と解説
[1:C,D]
JVM(Java仮想マシン)がOSの違いを吸収しているため、クラスファイルはOSに依存しません。
頻繁に呼び出されるコードはコンパイラによって最適化された状態で、
クラスファイルにコンパイルされます。

[2:E]
package宣言とimport宣言はソースファイルの先頭に記述し、
packageとimportの両方がある場合、packageを優先するので選択肢Eが正解。

[3:B]
Main.javaで使用しているaパッケージのFoo.javaはPublicではないので、
Main.javaではパッケージが異なるためbパッケージではFoo.javaは利用できません。
従って選択肢Bが正解
また、Foo.javaのアクセス修飾子がpublicであれば正しく動作し、
LocalDate.now()メソッドでの実行した日時が出力されます。

[4:E]
コンパイル時のコマンドは「java クラス名.java」でコンパイルを行います。
mainメソッド内のprintlnでの出力は、
args[1]、args[2]と配列の要素2番目、3番目を出力しているため
選択肢の中でコマンドライン引数の2番目、3番目に20 30としている物が正解になります。
従って選択肢Eが正解

[5:A]
要件2を見るとclasses以下に保存したい、とあるため
現在のディレクトリex-5から見て直下のディレクトリclassesにクラスファイルを出力する
-d classesの指定が必要と分かる。
javac -d 出力したいディレクトリ コンパイルしたいjavaファイル
という構文から選択肢D,Eは除外されます。
またjavaの実行はclassファイルに対して行われるので、
-cp・・・クラスパスオプション(クラスがどこにあるかのパス)を
上記classesディレクトリへ指定しなければならないため、
選択肢Cも除外されます。
また、クラスパスと実行するクラスは別々に分ける必要があるため
選択肢Bも除外されます。
従って残った選択肢Aが正解

[6:A]
B:必須ではない
C:コンストラクタが未定義の場合、引数を取らないデフォルトコンストラクタが
コンパイラによって自動生成されるので間違い
D:package宣言は未定義でも可
E:private,protectedは使用できないため間違い
従って選択肢Aが正解

[7:A]
x = y + 1 / 5は、まず1÷5が行われ、int型の整数として計算されるため0
従って x = 9 + 0という計算式でxには9が代入される
z / 4 も同様に整数として計算されるため2の整数となり
出力は9:2となるので選択肢Aが正解

8:A
選択肢BとDはそもそもの2次元配列のアクセス方法として間違い。
この図の場合、配列の先頭は左上から右に向かって[0,0][0,1][0,2]
真ん中の段で[1,0][1,1][1,2]
一番下の段で[2,0][2,1][2,2]
となるため10を格納した場合、
ary[1,2] = 10;
ary[2,0] = 10;
となるため選択肢Aが正解

[9:A,B,F]
A:NG。変数名に#は使用できない
B:NG。変数名にtrueは使用できない。true,false,nullは予約語ではないが、
リテラルとして処理されるため使用不可
C:OK。(short)とキャストすることによりshort型変数にも代入可能
※char型はint型と互換性がある
D:数値の途中にアンダースコアは使用可能
E:選択肢C同様にOK
F:NG。short型をchar型にはキャストなしでは不可
従って選択肢A,B,Fが正解

[10:A,B,E]
varによる型推論はローカル変数の初期化されている場合に限り使用が可能で、
メソッド・コンストラクタの引数、および戻り値型、メンバー変数には使用不可です。
そのため1行目、2行目のメンバ変数、メソッドの引数のためコンパイルエラーとなります。
3行目、4行目は=の右辺で初期化している（メソッド内の）ローカル変数のためOK。
5行目はvarのfinal化は可能だがvarの左にfinalがなければならないためNG。
6行目のfor文内のカウンタに使われている変数もローカル変数のためOK
従って選択肢A,B,Eが正解

[11:B]
最初のfor文での変数ar[0]の要素は、{a,b},ar[1]の要素は{e,f}となる。
2番目のchar型の配列で、ar[0]の要素abを出力後、空白1文字出力し、
ar[1]の要素を出力となるため、出力はab efとなる
従って選択肢Bが正解

[12:D]
mainメソッド内でのローカル変数x,yは初期化されていないため、
コンパイルエラーが発生します。
従って選択肢Dが正解。

[13:C]
変数dはメンバー変数（インスタンス変数）で、
変数宣言時に明示的に初期化されていません。
従ってMainクラスのインスタンスが作成時に暗黙的に初期化されますが、
Stringは参照型のためnullで初期化されます。
従って実行した結果はnullが出力されるため選択肢Cが正解
※Stringがintやdoubleなどの
プリミティブ型（数値型）の場合も確認しましょう
※また、nullのオブジェクトに対する操作(=メソッド呼び出し)は
NullPointerExceptionとなり実行時にエラー（例外）が発生します。

[14:C]
変数sは13問と同様のメンバー変数になり、
インスタンス作成時にはnullで初期化されます。(11行目)
12行目でfooメソッドを呼び出して「Dr.」の文字列を付加してますが、
メンバー変数のsに文字列を付加しているわけではないため
13行目の出力はnullのままとなります。
※fooメソッド内の
s += a;
を
this.s += a;
とするとどうなるかも確認しましょう。(nullDr.)

15:C
StringとStringBuilderクラスは両クラスともにreplaceメソッドがありますが、
Stringは引数は2つで"置き換え対象文字列"と"置き換え文字列"を渡します。
またStringBuilderクラスのreplaceメソッドは引数を3つとり、
StringBuilder#replace(
   "置き換えたい文字の開始位置"
   , "置き換えたい文字の終了位置"
   , "置き換え文字")
となります。
https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html#replace(int,int,java.lang.String)
A:従って選択肢Aはコンパイルエラーが出ます。
B:aqbcdと出力。開始位置と終了位置が同じsb.indexOf("b")、つまり1になっているため
、abcdのaとbの間にqが追加されるため間違い（※実際に動かして確認すること）
C:aqcdと意図した出力がされている
D:qbcdと出力
E:Bと同じ

[16:E]
7行目の「case 1: 2:」の箇所が構文ミスのためコンパイルエラーとなる。
従って選択肢Eが正解。
7行目が「case 1: case 2:」という記述であればコンパイルエラーは起きない。

[17:A]
caseで使用する値は定数でなければならないため7行目でコンパイルエラーがでます。
従って変数s1の宣言時にfinalを付加すればコンパイルエラーはなくなります。
9行目の"TUE"は文字列リテラルのためOK、11行目の変数s3は宣言時にfinalとして
定数としているためOKとなります。
従って選択肢Aが正解

[18:C]
三項演算子の問題。問題中に三項演算子が3つ組み込まれていますが
A ? B : C
の構文にAがfalseになった場合に、Cにまたこの構文が入っているだけの問題。

num < 4はfalseとなるため次の "X" : num < 6 では右辺に評価が遷移します。
この時点で選択肢Aは3項演算子の構文に沿っていないため間違い。
num < 6 はこれもfalseとなりますが、選択肢Dはここも3項演算子の構文に沿っていないため間違い
"Y" : num < 8の右辺に評価が遷移。
ここで選択肢Bも3項演算子の構文に沿っていないため間違い。
残る選択肢はCとなり、num < 8はtrueとなり、"Z"が返される。
従って選択肢Cが正解

[19:D]
プログラムの1行目から見ていくと
2行目のs.indexOf("is")でiに2が入る。
3行目は、s.substring(2)で2番目以降の文字を取得しているがどこにも代入していない
4行目はs自体変更されていないため再び2がiに代入
5行目は"this is no"の変数sの文字に"2"が付加されて出力
従って正解はD

[20:B]
StringBuilderのinsertメソッドは指定されたindexに文字を挿入するメソッドになります。
先頭(0番目に)に-1.同じく先頭に…と文字列を付加したら52-1という文字列になるので
選択肢Bが正しい。

[21:E]
7行目にfloat型変数(32ビット単精度浮動小数点)にdouble型(64ビット倍精度浮動小数点)
にキャストなしに代入しようとしているためコンパイルエラーとなります。

[22:D]
HelloWorldの文字列にsb.insert(6, " ");として空白を入れて、
HelloW orldとなって、
replaceメソッドによりoがeに置き換わっているので
HelloW erld
従って選択肢Dが正解

[23:C]
StringクラスのinternメソッドはStringクラスが管理しているメモリ領域に
同じ文字列があれば、その参照(住所)を返します。
そのため6行目のif文はtrueとなり、7行目が出力されます。
また5行目ではnew String()としているためstr3は新しい文字列オブジェクトになります。
※新しい住所が割り当てられている
そのた新しい文字列と9行目でifにて比較を行っているが、
equalsメソッドは同じ参照(住所)かどうかではなく文字として等しいかを比べているため
ここもtrueとなり10行目が出力されます。
従って選択肢Cが正解

[24:B]
正解は選択肢B。
実際にIDEを使って確認しましょう。
2行目のb = ++aが終了した時点で、a=101,b=101
3行目実行時にはcに101、(cに代入が完了後)b++でb=102
4行目はdに++cした値が、つまり102が代入されています。
整理すると4行目までが終了した時点で、
a=101
b=102
c=102
d=102
となります。
ここで三項演算子の a < bはtrueになるため、b < c
が評価されてfalseが出力されます。
従って選択肢Bが正解

[25:B,D]
A:90以上でも1.5が代入されてしまうので間違い
B:正解
C:三項演算子の構文が間違えているのでこれも誤り
D:正解
E:80未満でも1.5が代入されてしまうため間違い

[26:C]
プログラムのループ部分を見ると配列内の値が、
5014でない場合にインクリメント。
つまり配列の中に5014以外の数値がいくつあるか数えるプログラムになっているため
numは5012,5013,5015の3ということになります。
従って選択肢Cが正解。

[27:E]
変数dataが初期化されていないため、NullPointerExceptionが発生すので
実行時エラーとなります。
従って選択肢Eが正解

[28:C,E]
booleanの値はswitchには使用できないため選択肢A,Bは間違い。
※そもそも選択肢Aは
boolean val = "true"と文字列を代入しているためコンパイルエラー
同じく選択肢DもStringにtrueを代入しているためエラー。
残る選択肢はC,Eとなり
C:valをString型とし、case:"1"としているため正しく動作する。
E:trueを文字列型とし、case:"true"としているため正しく動作する
従って選択肢C,Eが正解

[29:B]
java00 4 9
00:ループ前のjava + (0/5)とループ1回目のSystem.out.print
4:1回目のループ最後で+1,ループの式3で+1,でi=2となるため
case 2:ブロックにて i *= 2で2倍されるためi=4に。
9:i=4でループ最後のインクリメント、式3でi=6に。6%5は1となるため
case 1:のブロックへ、ここでi=6に+3されて9に。

[30:C]
do-whileの問題ですが、whileの条件を見ると、
i<1が偽となったタイミングで終了するため、doブロックでi++;と
インクリメントされているためループは1度しか実行されません。
またインクリメントした直後のif文でcontinueされるため
何も出力されません
従って選択肢Ｃが正解

[31:C]
問題文のコードは0-9を出力するプログラムとわかる。
A:i==10の時breakとなるが、10も出力されるため間違い
B:++1となっているため1から出力されるため間違い
C:正解
D:forの式2がi<=10となっているため10まで出力されるため間違い
従って選択肢Cが正解

[32:A]
拡張for文でコマンドライン引数をループで回して出力するプログラム
iは単なる出力するためのカウンターで1から出力するため
選択肢Aが正解

[33:B]
2重ループで、2次元配列を単に出力するだけのプログラム
2次元目の配列を出力し終えた段階で、改行を出力しているため
選択肢Bが正解

[34:C]
do-while文で終了条件がary.length -1となっているところがポイント
つまり、変数countが配列の長さ3-1=2となった時点でループが終了するので
10 20しか出力されません
従って選択肢Cが正解

[35:A]
A:〇
B:× abstractなfinalメソッドは定義できない
C:× publicなfinalメソッドは定義できます。
D:× privateなコンストラクタは定義できます。※テキストの回答を参照
E:× protectedメソッドはサブクラス側でオーバーライド可能

[36:C]
選択肢Cが正解。コメントは不要だと思います。

[37:C]
コマンドライン引数でmainメソッドに渡された値はString[]となるため、
オーバーロードされたメソッドのprint(String... data)のメソッドに
渡され、print文でCが出力されます。
従って選択肢Cが正解

[38:A]
class Bはclass Aのサブクラスになるため
class Aのprotectedのコンストラクタも呼び出せます。
コンパイルエラーとなる要素がなにもないためA.java,B.javaともに
コンパイルは成功します。
従って選択肢Aが正解

[39:A]
classのインスタンスと、その参照変数、staticフィールド（クラスメンバ）
の良問題・
mainメソッドでnew Aとしてコンストラクタに"Japan"を渡し、
class Aのクラスメンバー変数valに代入。
その後、クラスAの参照変数objにnullを代入しobjの参照先である
Japanの値を持つclass Aのインスタンスへの参照をなくしますが、
インスタンスへの参照がないだけで、class Aへの参照がなくなったわけではない
※A obj = new A("Japan");と宣言しているここでclass Aへの参照はまだ生きている
従ってA.getValメソッドでJapanが出力されるため選択Aが正解

[40:A]
print文で出力しているのは先頭の0Bから2進数の数字となるため、
呼び出されるprint文はprint(int i)のメソッドが呼び出され、
"A"と出力されます。
従って選択肢Aが正解

[41:F]
staticなmainメソッドから(インスタンスを介さずに)呼び出されるため
methodもstaticでなければなりません。
従って選択肢D-Fのいずれかになります。
またprintln文で出力していることからint型を返すため
int[]の配列を受け取る選択肢Fが正解

[42:D]
メンバー変数のdataはfinalとなっており、
コンストラクタで初期化すれば問題なく動作します。
従ってコンストラクタで初期化していない9行目のデフォルトコンストラクタ
でコンパイルエラーとなるため選択肢Dが正解

[43:C]
インスタンス変数(メンバー変数)とクラス変数の問題
printlnで出力している変数aはインスタンス変数のため
コンストラクタで5にしかならないため、
出力している値の先頭(a)が5の選択肢が正解となるため選択肢D,Eは除外
またクラス変数のbは9行目で5、10行目で10となるので
出力は2行とも5 10となるので選択肢Cが正解

[44:B]
最初の出力文はp1はnullのためnull
2つ目の出力文はsuzukiが出力される
methodはPersonクラスのインスタンスを返すメソッドですが、
戻り値をどこにも代入していないため影響がない。

[45:D]
最初のprint文はaを出力しているだけなので300
次の出力はobj.barメソッドによってobj.a = 200となっているため
200が出力されます。
従って選択肢Dが正解

[46:B]
テキストの回答を参照
16行目時点でGC対象となるオブジェクトは１つ

[47:C]
(実装するメソッド引数) -> {処理};
という形式がラムダ式の基本形になります。
参照される変数iもラムダ式の処理の中で利用できますが、
その変数はfinal化、または実質的にfinalな(=変更されない)必要があるため
i++の箇所でコンパイルエラーが発生する。
従って選択肢Cが正解

[48:D]
Arrays.mismatch関数は配列同士の比較し、最初に要素が不一致となった
インデックスを返します。
またcompareメソッドは要素の値が全く同じであれば0、
辞書的に小さい場合は0より小さい値、逆に大きい場合は1以上の数値を返す。
従って選択肢Dが正解

[49:C]
選択肢を見るとParentクラスのfooメソッドのオーバーライド、または
オーバーロードの問題だとわかる。
選択肢B,Dは引数の型がことなるためオーバーロードとみなされます。
(=つまり別メソッドのためコンパイルエラーは発生しない)
選択肢AはParentクラスのfooメソッドと全く同じなのでオーバーライドと
見なされますが、全く同じなのでコンパイルエラーは起きない
選択肢Cはオーバーライドになりますが、オーバーライド時は
サブクラスで型パラメータを変えられないためコンパイルエラーが発生します。
従って選択肢Cが正解

[50:A,B]
mapインタフェースのvaluesメソッドはCollectionインターフェースの実装を返します。
従って選択肢A,Bが正解になります。
A,Bともに親クラスのsetメソッドを呼び出し、map.values()メソッドにて
コレクションを渡しているためコンパイルは成功します。
また選択肢Cは、Mapはコレクションインターフェースの実装ではないためコンパイルエラーになります。
選択肢Dは親クラスにアクセス可能なmapがないためコンパイルエラー、
選択肢Eも文法自体が誤りのためコンパイルエラーとなります。
従って選択肢A,Bが正解

[51:A,B,E,G]
インターフェースで宣言した変数は暗黙的にpublic,static,finalとなり、
定数となるため、選択肢C,Dのように変更は出来ません。
上記の理由から利用する際は選択肢A,B,Eのように直接アクセスするか、
選択肢Gのようにインターフェースを実装したクラスからアクセスすることになります。
※選択肢Gを「Main.num2」のようにもアクセスは可能
従って選択肢A,B,E,Gが正解

[52:B]
defaultメソッドはprivate修飾子使用できないが、staticメソッドは可能。
従って選択肢Bのコンパイルエラーとなります。
正解は選択肢Bとなります。

[53:D]
13行目でChildクラスをParentクラスの変数に代入していますが、
14行目のprintメソッドはインスタンスメソッド、つまりnewされた
オブジェクトのprintメソッドが呼ばれるため9行目が呼ばれて"B"が出力。
15行目はインスタンス変数にアクセスしているため
4行目が呼び出され"A"が出力されます。
従って選択肢Dが正解


[54:B]
実行行を追ってみると
10→11→7→6→2→3(b)→2(a)→6(c)→7(d)→11となります。
従って選択肢Bが正解
※IntelliJでステップ実行して動きを確認してください！

55:D
56:D
57:A
58:B
59:E
60:A
61:C
62:A
[63:A,B]
インターフェースに記述されたメソッドは暗黙的（自動的）に
public,abstractなメソッドになります。
記述してよいアクセス修飾子の記述はpublicと、privateはstaticメソッドのみ記述できます。
従って選択肢C,Eは間違いとなります。
また選択肢Dはmethod(int a){}と実装しているためこれも間違いになるため
残った選択肢A,Bが正解

64:C
65:E
66:F
67:B

[68:B]
小文字での文字列を大文字に変換するメソッドは
StringクラスのtoUpperCase()メソッドになります。
選択肢Aは拡張for文でs.toUpperCase();と大文字化
していますが、配列のindexを指定してないためRED,BLUE,GREEN
にはなりません。(そもそもコンパイルエラー)
同様に選択肢Dもfor文でループしてtoUpperCaseメソッドを呼び出していますが、
大文字にしてもどこにも代入していないためこれも間違い
残りの選択肢はB,Cですが、選択肢Cはs -> toUpperCase()と呼び出していますので
コンパイルエラーとなります。(s.toUppderCase()としていればOK)
従って選択肢Bが正解となります。

69:C
70:A,C
71:C,E
[72:C]
・例外クラスのクラス構造
Throwable
┣ Error                 //回復の見込みがない例外（エラー）
┗ Exception             //回復の見込みがある例外(checked例外)
   ┗ RuntimeException   //エラー対応不要な例外(unchecked例外)
回復の見込みがある例外・・・つまりtryしてcatch出来たら元の処理に戻れるかもしれない例外
ということになります。またErrorクラスはプログラムの実行環境（JVM）側の問題が大きいので
（プログラム側の問題が原因の可能性はありますが）例外処理することはありません。
またRuntimeExceptionは日本語に訳すと実行時例外、となりますのでRuntimeExceptionが
発生しそうな箇所でもtry-catchの例外処理は必要ありません。
実行時にのみ起こりうる例外なのでコンパイル時にはエラーになりません。
※テキストでは任意となっています
※これは私がこれが発生したらプログラマーとして恥だといっていた例外になります
（事前に例外が発生しないようにチェックを行って未然に防ぎます）
問題では、ExceptionクラスをthrowするmethodAと、
RuntimeExceptionをthrowするmethodBが呼び出されています。
上記の説明からmethodAの呼び出しの個所で例外処理（つまりtry-catchの処理）が必要だとわかります。
またmethodBはRuntimeExceptionを投げる可能性がありますが、
前述のとおり、例外処理は不要のため、例外処理が不足しているline3でコンパイルエラーとなります。
従って選択肢Cが正解

※例外のわかりやすいURL：https://programmer-life.work/java/runtime-exception-java

73:C
74:D
75:A,B
76:A
77:C
78:B,C,F
79:D
80:A

