#模擬試験1の回答と解説
[1:C,D]
JVM(Java仮想マシン)がOSの違いを吸収しているため、クラスファイルはOSに依存しません。
頻繁に呼び出されるコードはコンパイラによって最適化された状態で、
クラスファイルにコンパイルされます。

[2:E]
package宣言とimport宣言はソースファイルの先頭に記述し、
packageとimportの両方がある場合、packageを優先するので選択肢Eが正解。

[3:B]
Main.javaで使用しているaパッケージのFoo.javaはPublicではないので、
Main.javaではパッケージが異なるためbパッケージではFoo.javaは利用できません。
従って選択肢Bが正解
また、Foo.javaのアクセス修飾子がpublicであれば正しく動作し、
LocalDate.now()メソッドでの実行した日時が出力されます。

[4:E]
コンパイル時のコマンドは「java クラス名.java」でコンパイルを行います。
mainメソッド内のprintlnでの出力は、
args[1]、args[2]と配列の要素2番目、3番目を出力しているため
選択肢の中でコマンドライン引数の2番目、3番目に20 30としている物が正解になります。
従って選択肢Eが正解

[5:A]
要件2を見るとclasses以下に保存したい、とあるため
現在のディレクトリex-5から見て直下のディレクトリclassesにクラスファイルを出力する
-d classesの指定が必要と分かる。
javac -d 出力したいディレクトリ コンパイルしたいjavaファイル
という構文から選択肢D,Eは除外されます。
またjavaの実行はclassファイルに対して行われるので、
-cp・・・クラスパスオプション(クラスがどこにあるかのパス)を
上記classesディレクトリへ指定しなければならないため、
選択肢Cも除外されます。
また、クラスパスと実行するクラスは別々に分ける必要があるため
選択肢Bも除外されます。
従って残った選択肢Aが正解

[6:A]
B:必須ではない
C:コンストラクタが未定義の場合、引数を取らないデフォルトコンストラクタが
コンパイラによって自動生成されるので間違い
D:package宣言は未定義でも可
E:private,protectedは使用できないため間違い
従って選択肢Aが正解

[7:A]
x = y + 1 / 5は、まず1÷5が行われ、int型の整数として計算されるため0
従って x = 9 + 0という計算式でxには9が代入される
z / 4 も同様に整数として計算されるため2の整数となり
出力は9:2となるので選択肢Aが正解

8:A
選択肢BとDはそもそもの2次元配列のアクセス方法として間違い。
この図の場合、配列の先頭は左上から右に向かって[0,0][0,1][0,2]
真ん中の段で[1,0][1,1][1,2]
一番下の段で[2,0][2,1][2,2]
となるため10を格納した場合、
ary[1,2] = 10;
ary[2,0] = 10;
となるため選択肢Aが正解

[9:A,B,F]
A:NG。変数名に#は使用できない
B:NG。変数名にtrueは使用できない。true,false,nullは予約語ではないが、
リテラルとして処理されるため使用不可
C:OK。(short)とキャストすることによりshort型変数にも代入可能
※char型はint型と互換性がある
D:数値の途中にアンダースコアは使用可能
E:選択肢C同様にOK
F:NG。short型をchar型にはキャストなしでは不可
従って選択肢A,B,Fが正解

[10:A,B,E]
varによる型推論はローカル変数の初期化されている場合に限り使用が可能で、
メソッド・コンストラクタの引数、および戻り値型、メンバー変数には使用不可です。
そのため1行目、2行目のメンバ変数、メソッドの引数のためコンパイルエラーとなります。
3行目、4行目は=の右辺で初期化している（メソッド内の）ローカル変数のためOK。
5行目はvarのfinal化は可能だがvarの左にfinalがなければならないためNG。
6行目のfor文内のカウンタに使われている変数もローカル変数のためOK
従って選択肢A,B,Eが正解

[11:B]
最初のfor文での変数ar[0]の要素は、{a,b},ar[1]の要素は{e,f}となる。
2番目のchar型の配列で、ar[0]の要素abを出力後、空白1文字出力し、
ar[1]の要素を出力となるため、出力はab efとなる
従って選択肢Bが正解

[12:D]
mainメソッド内でのローカル変数x,yは初期化されていないため、
コンパイルエラーが発生します。
従って選択肢Dが正解。

[13:C]
変数dはメンバー変数（インスタンス変数）で、
変数宣言時に明示的に初期化されていません。
従ってMainクラスのインスタンスが作成時に暗黙的に初期化されますが、
Stringは参照型のためnullで初期化されます。
従って実行した結果はnullが出力されるため選択肢Cが正解
※Stringがintやdoubleなどの
プリミティブ型（数値型）の場合も確認しましょう
※また、nullのオブジェクトに対する操作(=メソッド呼び出し)は
NullPointerExceptionとなり実行時にエラー（例外）が発生します。

[14:C]
変数sは13問と同様のメンバー変数になり、
インスタンス作成時にはnullで初期化されます。(11行目)
12行目でfooメソッドを呼び出して「Dr.」の文字列を付加してますが、
メンバー変数のsに文字列を付加しているわけではないため
13行目の出力はnullのままとなります。
※fooメソッド内の
s += a;
を
this.s += a;
とするとどうなるかも確認しましょう。(nullDr.)

15:C
StringとStringBuilderクラスは両クラスともにreplaceメソッドがありますが、
Stringは引数は2つで"置き換え対象文字列"と"置き換え文字列"を渡します。
またStringBuilderクラスのreplaceメソッドは引数を3つとり、
StringBuilder#replace(
   "置き換えたい文字の開始位置"
   , "置き換えたい文字の終了位置"
   , "置き換え文字")
となります。
https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html#replace(int,int,java.lang.String)
A:従って選択肢Aはコンパイルエラーが出ます。
B:aqbcdと出力。開始位置と終了位置が同じsb.indexOf("b")、つまり1になっているため
、abcdのaとbの間にqが追加されるため間違い（※実際に動かして確認すること）
C:aqcdと意図した出力がされている
D:qbcdと出力
E:Bと同じ

[16:E]
7行目の「case 1: 2:」の箇所が構文ミスのためコンパイルエラーとなる。
従って選択肢Eが正解。
7行目が「case 1: case 2:」という記述であればコンパイルエラーは起きない。

[17:A]
caseで使用する値は定数でなければならないため7行目でコンパイルエラーがでます。
従って変数s1の宣言時にfinalを付加すればコンパイルエラーはなくなります。
9行目の"TUE"は文字列リテラルのためOK、11行目の変数s3は宣言時にfinalとして
定数としているためOKとなります。
従って選択肢Aが正解

[18:C]
三項演算子の問題。問題中に三項演算子が3つ組み込まれていますが
A ? B : C
の構文にAがfalseになった場合に、Cにまたこの構文が入っているだけの問題。

num < 4はfalseとなるため次の "X" : num < 6 では右辺に評価が遷移します。
この時点で選択肢Aは3項演算子の構文に沿っていないため間違い。
num < 6 はこれもfalseとなりますが、選択肢Dはここも3項演算子の構文に沿っていないため間違い
"Y" : num < 8の右辺に評価が遷移。
ここで選択肢Bも3項演算子の構文に沿っていないため間違い。
残る選択肢はCとなり、num < 8はtrueとなり、"Z"が返される。
従って選択肢Cが正解

[19:D]
プログラムの1行目から見ていくと
2行目のs.indexOf("is")でiに2が入る。
3行目は、s.substring(2)で2番目以降の文字を取得しているがどこにも代入していない
4行目はs自体変更されていないため再び2がiに代入
5行目は"this is no"の変数sの文字に"2"が付加されて出力
従って正解はD

[20:B]
StringBuilderのinsertメソッドは指定されたindexに文字を挿入するメソッドになります。
先頭(0番目に)に-1.同じく先頭に…と文字列を付加したら52-1という文字列になるので
選択肢Bが正しい。

[21:E]
7行目にfloat型変数(32ビット単精度浮動小数点)にdouble型(64ビット倍精度浮動小数点)
にキャストなしに代入しようとしているためコンパイルエラーとなります。

[22:D]
HelloWorldの文字列にsb.insert(6, " ");として空白を入れて、
HelloW orldとなって、
replaceメソッドによりoがeに置き換わっているので
HelloW erld
従って選択肢Dが正解

[23:C]
StringクラスのinternメソッドはStringクラスが管理しているメモリ領域に
同じ文字列があれば、その参照(住所)を返します。
そのため6行目のif文はtrueとなり、7行目が出力されます。
また5行目ではnew String()としているためstr3は新しい文字列オブジェクトになります。
※新しい住所が割り当てられている
そのた新しい文字列と9行目でifにて比較を行っているが、
equalsメソッドは同じ参照(住所)かどうかではなく文字として等しいかを比べているため
ここもtrueとなり10行目が出力されます。
従って選択肢Cが正解

[24:B]
正解は選択肢B。
実際にIDEを使って確認しましょう。
2行目のb = ++aが終了した時点で、a=101,b=101
3行目実行時にはcに101、(cに代入が完了後)b++でb=102
4行目はdに++cした値が、つまり102が代入されています。
整理すると4行目までが終了した時点で、
a=101
b=102
c=102
d=102
となります。
ここで三項演算子の a < bはtrueになるため、b < c
が評価されてfalseが出力されます。
従って選択肢Bが正解

25:B
26:D
27:E
28:C,E
29:B
30:C
31:C
32:A
33:B
34:C
35:A
36:C
37:C
38:A
39:A
40:A
41:F
42:D
43:C
44:B
45:D
46:B
47:C
48:D
49:C
50:A,B
51:A,B,E,G
52:B
53:D
54:B
55:D
56:D
57:A
58:B
59:E
60:A
61:C
62:A
63:A,B
64:C
65:E
66:F
67:B
68:B
69:C
70:A,C
71:C,E
72:C
73:C
74:D
75:A,B
76:A
77:C
78:B,C,F
79:D
80:A

