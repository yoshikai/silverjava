[lesson6_1:B,F]
選択肢を見るとすべてmethodという名前のメソッド名になっていることから
オーバーライドの問題だとわかる。(※一部引数が異なるためオーバーロード)
オーバーライドは親クラスのメソッド同じシグネチャで、親クラスのメソッドと振る舞い(処理が異なる)
が違うものを再定義する際に使用します。
またメソッドのアクセス修飾子（スコープ）は親クラスのメソッドより、より広いアクセスが可能なものでなければいけません。
そのため各選択肢は
A:スコープがpublicになっているだけなのでOk
B:intを帰すようになっているためNG
C:引数のみ異なっているためオーバーロード。OK
D:Cと同様
E:デフォルトよりprotectedがより広いアクセスが可能なためOK
F:デフォルトよりprivateは狭いアクセスになるためNG
従ってコンパイルエラーとなる選択肢はB,F

[lesson6_2:D ]
AのサブクラスにBを定義し、mainメソッドにて
A型の配列を作成、要素[0]にAのインスタンス、
要素[1]にBのインスタンスを代入している。
参照型の型変換は配列にも適用されるためプログラムはコンパイル、
実行ともに成功する。従って選択肢Dが正解

[lesson6_3:A ]
ChildクラスのインスタンスからParentクラスに定義されているshowメソッドを呼び出した際に、
最初にChildクラスのshowメソッドを探しますが、見つからないので親クラスのshowメソッドを検索し、
見つかった場合は、そのまま実行します。その時変数numは親クラスのnumを参照するため100が出力される。
※変数numをサブクラスに探したりはしない。500を出力させたい場合は、
Childクラスでshowメソッドをオーバーライドすればよいだけ。
従って選択肢Aが正解

[lesson6_4:E ]
A:インターフェースのメソッドは自動的にpublic扱いとなるためコンパイルエラーとなるは間違い
B:クラスBにimplements Aの宣言が無くてもコンパイルエラーにはならない
C:サブクラスとインターフェースの両方の実装時はextends XXX implemets YYYの並びのため問題なし
D:Cクラス内にメソッドxがなくてもクラスBに定義済みのため問題なし。
E:抽象クラス、インターフェースの実装ともに問題ないため、正解
正解は選択肢E

[lesson6_5:B ]
クラス階層でクラスDは何も継承していないためクラスDのインスタンスobj3を出力している
選択委C,Dはまず間違いであると気づく。
またmainメソッド内は、クラスB,C,Dをそれぞれインスタンス化させ、
if文でinstanceof演算子でインターフェースAのインスタンスを調べているだけであり、
コンパイル・実行時エラーはありえないため選択肢E,Fも間違い。
インターフェースAの実装クラスがクラスBであり、
クラスBのサブクラスがクラスCである。
instanceof演算子でインターフェースAのインスタンスかどうかを調べているが、
クラスBはもちろん、サブクラスのクラスCもインターフェースAのインスタンスであるため、
obj1,obj2が出力される選択肢Bが正解

[lesson6_6:B]
methodA,methodBともに変数x,yにそれぞれx,yを代入しているだけだが、
仮引数の変数がメンバー変数と同じx,yと同じなためmethodAでは、
メンバー変数のx,yには代入されない。
従って出力は
methodA: 0 0
methodB: 50 60
となるため選択肢Bが正解

[lesson6_7:C]
※ちょっと難しい問題
クラスBのコンパイル時にコンパイラはBの引数を取らないコンストラクタと
同じ引数を取らないコンストラクタをAのコンストラクタを暗黙的に呼び出そうとしますが(super())
親クラスのAにはStringを受け取るコンストラクタが定義済みのためデフォルトコンストラクタが生成できないため
コンパイルエラーが発生する。
従って正解の選択肢Cが正解

[lesson6_8:C]
※ちょっと難しい問題
親クラスのコンストラクタの呼び出し方の問題。
mainメソッドを見てみると、11行目でまず引数を取らないコンストラクタが呼び出されています。
この11行目は17行目のコンストラクタを呼び出そうとしていますが、
親クラスにデフォルトコンストラクタが定義されていないため、コンパイルエラーとなりますが、
空欄[1]にMySuperClass(){}のデフォルトコンストラクタがあると正常に動作します
この場合、空欄[2]は何も入れなくて空行でOK
また親クラス、サブクラスともにint型を受け取るコンストラクタを定義しているため
空欄[2]にthis(5);とあれば、引数を取らないコンストラクタからint型引数を取るコンストラクタ呼び出され、
super(i)が実施されるため正常に動作します。従ってthis(5);の選択肢2も正しく動作します。
正解は1と2のどちらかがあれば正常に動作するため選択肢Cが正解

[lesson6_9:B]
まず選択肢をざっと見渡すとSuperClass()という(コンストラクタ見せかけた)メソッド呼び出しを
していますが、こんなメソッドは未定義のため選択肢E,Fは間違いのため除外
次に、自身のコンストラクタを呼び出すthis()は、
同じサブクラス内の他のコンストラクタを呼び出す際に使用できますが、
ここでは他のコンストラクタをコンストラクタを未定義のためC,Dも除外
残りのA,Bは親クラスのコンストラクタを呼び出すsuper(j);となりますが、
super()の呼び出しはコンストラクタ内の先頭で行わないといけないため
選択肢Bが正解。

[lesson6_10:E]
問題8,9と同様にデフォルトコンストラクタの問題。
スーパークラスにデフォルトコンストラクタがなく、
サブクラスで引数をとらないコンストラクタを宣言している。
そのため16行目のサブクラスの引数をとらないコンストラクタでコンパイルエラーが発生する
従って正解は選択肢E
またこの引数をとらないコンストラクタ内の先頭でthis(1)やsuper(i)を記述すると
コンパイルエラーは発生しない。

[lesson6_11:A,B]
選択肢C,DはMyClassの実装クラスにも関わらず、
メソッドx,メソッドyに実装されていないためコンパイルエラー
選択肢E,Fはimplementsとインターフェースの実装になっているためコンパイルエラーとなる。
選択肢AはMyClassの実装クラスとして正しく継承されているためOK
選択肢BはMyClassの抽象サブクラスとして
新たに抽象メソッドyを宣言しているがこれも正しく継承しているためOK
従って正解は選択肢A,B

[lesson6_12:D]
インターフェースは(JavaSE8より)実装を持つメソッド(デフォルトメソッド)と、
staticメソッドが使用可能。またアクセス修飾子を付加しない場合も
コンパイル時に自動的にpublicとなる。
protectedは使用不可(コンパイルエラーとなる)
privateはstaticメソッドのみ使用可
上記のことから問題文のインターフェースは問題なく動作するので正解は選択肢Dとなる。

[lesson6_13:A,E]
インターフェースの実装はimplementsキーワードを使用するため
継承を行うextendsキーワードを使用している、B,D,Fは間違い
残りA,C,Eを見ると、
A:インターフェースA,Bのメソッドm1,m2をPublicで実装しているため問題く動作します。
C:選択肢AとCの違いはm2メソッドのアクセス修飾子にPublicとなっているかどうかの違いですが、
  インターフェースのメソッドはアクセス修飾子が記述されていない場合、暗黙的にpublicでコンパイルされます。
  従ってそれを実装するクラスでもpublicで記述しないと適切にオーバーライドできないため、選択肢Cは間違い
E:インターフェースA,Bを実装した抽象クラスを定義しています。
  抽象クラスのためimplementsしたインターフェースを必ず実装する必要がないため、
  ここではメソッドm2のみ実装している状態ですが問題なし。
従って正解は選択肢A,E

[lesson6_14:D]
meinメソッドを見てみると、
1.lectureHall(大教室)型のインスタンスを作成
2.Auditorium(講堂)型の変数宣言
3.Facilities(設備)型の変数宣言
4.3の変数に1を代入
5.2の変数に2の型にキャストして3を代入
1から3は問題なし、
続いて4を細かく見ると、
Facilitiesインタフェースに代入しているLectureHallクラスはClassRoomを継承しているクラスになり、
そのClassRoomはFacilitiesインスタンスを実装していることから、問題なし。
続いて5行目は
Auditorium型変数に4行目でFacilities型変数に代入されたf1を、
Auditorium型にキャストして代入している。
LectureHall1→Facilities→Auditoriumにキャスト
FacilitiesインターフェースはLectureHallクラス、Auditoriumともに実装しているため
プログラム上はコンパイルエラーも発生しないが、実行時にそもそも
LectureHallクラスと、Auditoriumクラスはスーパークラスが同じClassRoomとはいえ、
別々のクラスのため実行時にClassCastExceptionが発生する。
従って正解は選択肢D

[lesson6_15:A,B,C,G]
A. 親クラスのインターフェース変数に実装クラスのインスタンスを代入は問題なし
B. 親クラスのインターフェース変数にDouクラスのサブクラスを代入しているため問題なし
C. 親クラスのDueにサブクラスのHauのインスタンスを代入しているため問題なし
D. Hau型の変数にWia型の変数は親クラスが同じでも互換性がないためコンパイルエラー
E. サブクラスの変数に親クラスのインスタンスをそのまま代入はできない。キャストが必要
F. 同じ親クラスを持つサブクラスWia型変数へのHauインスタンスの代入はできない
G. 選択肢Eと同じだがWiaクラスにキャストしているため問題なし
従って正解は選択肢A,B,C,G

[lesson6_16:D]
ポリモフィズムのstaticメソッドの振る舞いの問題。
ポリモフィズムはstaticメソッドには適用されないため、
Animal型の配列に代入した時点で、Animal型のstaticメソッドが呼ばれるため
saySomethingメソッドでは"Gurrr Gurrr"が出力される。
従って正解は選択肢D

[lesson6_17:C]
問16の類似問題。
16とは逆にインスタンスメソッドのためポリモフィズムが適用されるため
配列に入っているAnimal,CowそれぞれのsaySomethingメソッドが呼ばれるため
Gurrr! Moo!と出力される。
従って正解は選択肢C

[lesson6_18:A]
問16の類似問題。
yメソッドは2行目のstaticメソッドを呼び出すため出力は
Animal Cow
となるため正解は選択肢A

[lesson6_19:A]
mainメソッドではFooクラスのインスタンスメソッドmethodに文字列型を渡しています。
クラスFooではString型を受け取るメソッドは定義していませんが、
Object型で受け取るメソッドがあるため
このメソッドが暗黙の型変換により呼び出されObjectの文字列が表示されます。
従って正解は選択肢A

[lesson6_20:D]
java.util.Listはjava.util.Collectionインターフェースのサブクラスの実装になります。
そのためCollectionを返すという意味では4行目も6行目も同じ引数、同じ戻り値を返すことになるので、
4行目以降に定義された6行目でコンパイルエラーが発生します。
5行目は引数の型がListとなっているため4行目とは異なるためOK
7行目は引数がMapインターフェースのためOK
従って正解は選択肢D

[lesson6_21:A,F ]
Fooインターフェースは抽象メソッドを1つだけの関数型インターフェースとなります。
メソッドはdoubleの値を引数に取り、-1を返す仕様になっています。
選択肢Aは暗黙の関数を省略し、-1を返す仕様になっているため正解。
選択肢Bはreturnも無く-1のあとにセミコロンがないためコンパイルエラー
選択肢C,Dは引数変数dが既に定義済みで変数名が重複するためコンパイルエラー
選択肢Eはreturn iの後ろにセミコロンがないためコンパイルエラー
選択肢Fは正しく動作する
従って正解は選択肢A,F

[lesson6_22:A ]
配列の要素の比較問題。
Arrays.mismatch(配列A, 配列B)メソッドは配列の要素１つずつ先頭から比較し、
両配列が全く同一であれば-1を、異なる要素があればその添え字を返す仕様になります。
比較された配列はapple,bananaとApple,Bananaでmismatchは大文字小文字も区別するため
要素0のappleとAppleが異なるため0を返します。
※appleが同じ場合、次の要素1のbanana,Bananaを比較し要素1のインデックスの1を返す。
※要素の何文字目か？ではないので注意。
従って正解は選択肢A

[lesson6_23:E ]
java.util.function.Supplierインターフェースは以下の特徴があります。
・関数型インターフェースでget()メソッドのみ定義されている。
・Supplierは、供給者という意味のため出力のみで入力となる引数なし。
・Supplier<T>のTはメソッドの戻り値の型
※java Doc
https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/function/Supplier.html

fooメソッドの引数を見るとSupplierの実装を取るため、このような問題の場合、
(Supplierインターフェースを知らなくくても)8行目のobj.get()が
実装部分になるだろうなと推測してください。
5行目の
() -> 10
の箇所は引数が無く戻り値で10を返す関数になっています。
※ちょっと分かりづらいですが、名前のない10を返す関数をfooメソッドに渡していると思ってください)
8行目はSupplier関数インターフェースのgetメソッドを呼び出して10を出力しているため
問題なく動作する
プログラムになります。
そのため正解は選択肢E

[lesson6_24:C ]
3項演算子(? true: false)にsubstring(0,5)があります、ここでは、
5文字以上の文字列は、先頭から5文字切り出す処理を行っているため、
選択肢の中で、配列の要素で5文字以上出ている選択肢は間違いになります。
従って選択肢A,Bは除外されます。
選択肢Dは5文字未満の配列の要素に文字[s]を付加していますが、そのような処理はmainメソッドにはありません。
ラムダ式でreplaceAllを記述しているだけなのでコンパイルエラーも発生しないため
正解は選択肢C

[lesson6_25:E ]
※引っ掛け問題
配列の各要素の文字数が3文字以下なら配列から削除し出力する、という処理ですが、
配列を削除しようとするとUnSupportedOperationException例外を発生するため
正解は選択肢Eとなる。

※asListメソッドの機能は、あくまで配列をコレクションフレームワークで利用できるように、
配列をあたかもListのように見せているだけで固定サイズのリストのため
要素数を変更するような操作を行うとUnSupportedOperationException例外を発生
